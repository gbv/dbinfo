#!/bin/sh
### BEGIN INIT INFO
# Provides:          {$package_name}
# Required-Start:    $network $local_fs $remote_fs
# Required-Stop:     $remote_fs
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: {$package_name}
# Description:       {$package_description}
### END INIT INFO
# Author: {$author}

set -e
 
DESC={$package_name}
NAME={$package_name}
SCRIPTNAME=/etc/init.d/$NAME
 
APPUSER=$NAME
APPDIR=/srv/$NAME
PIDFILE=/var/run/$NAME.pid
WORKERS=5
PORT=6006
STARTUP_TIME=30
LISTEN=":$PORT" # or 127.0.0.1:$PORT
LOGDIR=/var/log/$NAME

DAEMON=/srv/$NAME/run.sh
DAEMON_ARGS="-- --daemonize --user $APPUSER --preload-app --workers $WORKERS --pid $PIDFILE -listen $LISTEN --error-log $LOGDIR/error.log --access-log $LOGDIR/access.log"

# Read configuration variable file if it is present
[ -r /etc/default/$NAME ] && . /etc/default/$NAME

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh
 
# Define LSB log_* functions.
# Depend on lsb-base (>= 3.0-6) to ensure that this file is present.
. /lib/lsb/init-functions
 
check_running() \{
    [ -s $PIDFILE ] && kill -0 $(cat $PIDFILE) >/dev/null 2>&1
\}


_start() \{
 
  /sbin/start-stop-daemon --start --pidfile $PIDFILE --chdir $APPDIR --exec $DAEMON -- $DAEMON_ARGS \
    || return 2
 
  echo ""
  echo "Waiting for $NAME to start..."
 
  for i in `seq $STARTUP_TIME` ; do
    sleep 1
    if check_running ; then
      echo "$NAME is now starting up"
      return 0
    fi
  done
 
  return 1
\}
 
start() \{
    log_daemon_msg "Starting $NAME"
    echo ""
 
    if check_running; then
        log_progress_msg "already running"
        log_end_msg 0
        exit 0
    fi
 
    rm -f $PIDFILE 2>/dev/null
 
    _start
    log_end_msg $?
    return $?
\}
 
stop() \{
    log_daemon_msg "Stopping $NAME"
    echo ""
 
    /sbin/start-stop-daemon --stop --oknodo --pidfile $PIDFILE
    sleep 3
    log_end_msg $?
    return $?
\}
 
restart() \{
    log_daemon_msg "Restarting $NAME"
    echo ""
 
    /sbin/start-stop-daemon --stop --oknodo --pidfile $PIDFILE
    _start
    log_end_msg $?
    return $?
\}

status() \{
    if [ -f $PIDFILE ]; then
        PID=`cat $PIDFILE`
        if check_running; then
            LSPORT=`lsof -a -p$PID -i4 -i6 -P | grep LISTEN | awk '\{print $9\}' 2>/dev/null`
            echo "$NAME is running (pid $PID listening on $LSPORT)"
        else
            echo "$NAME is not running but $PIDFILE exists"
        fi
    else
        echo "$NAME is not running"
    fi
\}

# See how we were called.
case "$1" in
    start)
        start
    ;;
    stop)
        stop
    ;;
    restart|force-reload)
        restart
    ;;
    status)
        status
    ;;
    *)
        echo "Usage: $0 \{start|stop|restart\}"
        exit 1
esac
exit $?

